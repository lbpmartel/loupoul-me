---
slug: making-your-ui-tests-resilient-to-change
title: Rendre vos tests UI rÃ©silients aux changements
date: "2019-10-07"
translation-date: "2021-06-23"
author: Kent C. Dodds
translator: Louis-Bernard Poulin Martel
description: "Les tests d'interface utilisateur sont reconnus pour briser facilement. Voyons comment nous pourrions amÃ©liorer ceci."
keywords:
  - javascript
  - testing
  - Ui Testing
  - Unit Testing
  - Integration Testing
banner: "./images/banner.jpg"
bannerCredit: "Photo by [Warren Wong](https://unsplash.com/photos/tHiGKAJxaA8)"
---

Version originale :

- [Article Â«Making your UI tests resilient to changeÂ» de Kent C. Dodds](https://kentcdodds.com/blog/making-your-ui-tests-resilient-to-change)

Traductions libres prÃ©sentement disponibles :

- [Chinois traditionel](https://medium.com/enjoy-life-enjoy-coding/react-unit-test-%E8%AE%93%E4%BD%A0%E7%9A%84-ui-%E6%B8%AC%E8%A9%A6%E9%81%A9%E6%87%89%E8%AE%8A%E5%8C%96-%E7%BF%BB%E8%AD%AF-b9b2c1c4110f)

Vous Ãªtes un dÃ©veloppeur et vous voulez Ã©viter de livrer un service de connexion qui ne
fonctionne pas. Vous Ã©crivez donc des tests pour vous assurer que Ã§a n'arrive pas.
Regardons ici un exemple d'un [formulaire de ce genre](https://github.com/kentcdodds/testing-workshop/blob/1938d6fc2048e55362679905f700f938a3b497c4/client/src/screens/login.js#L50-L82) :

![Login form from the Bookshelf App](./images/image-1.png)

```jsx
const form = (
  <form onSubmit={handleSubmit}>
    <div>
      <label htmlFor="username">Username</label>
      <input id="username" className="username-field" />
    </div>
    <div>
      <label htmlFor="password">Password</label>
      <input id="password" type="password" className="password-field" />
    </div>
    <div>
      <button type="submit" className="btn">
        Login
      </button>
    </div>
  </form>
)
```

Si nous avions Ã  tester ce formulaire, nous voudrions remplir le champ Â« username Â»,
le champ Â« password Â» et ensuite soumettre le formulaire. Pour faire cela correctement,
nous aurions Ã  rendre le formulaire et trouver les noeuds dans le document pour pouvoir
les utiliser. Voici ce que vous pourriez vouloir faire pour que cela se produise :

```js
const usernameField = rootNode.querySelector(".username-field")
const passwordField = rootNode.querySelector(".password-field")
const submitButton = rootNode.querySelector(".btn")
```

C'est ici que le problÃ¨me entre en jeu. Qu'arrive-t-il lorsque l'on ajoute un autre
bouton? Que se passerait-il si l'on ajoutait un bouton Â« Sign up Â» avant le bouton
Â« Login Â»?

```jsx {12-14}
const form = (
  <form onSubmit={handleSubmit}>
    <div>
      <label htmlFor="username">Username</label>
      <input id="username" className="username-field" />
    </div>
    <div>
      <label htmlFor="password">Password</label>
      <input id="password" type="password" className="password-field" />
    </div>
    <div>
      <button type="submit" className="btn">
        Sign up
      </button>
      <button type="submit" className="btn">
        Login
      </button>
    </div>
  </form>
)
```

Et bien, Ã§a va briser nos tests. Mais ce serait assez simple Ã  rÃ©parer, n'est-ce pas?

```js
// changer ceci :
const submitButton = rootNode.querySelector(".btn")
// pour ceci :
const submitButton = rootNode.querySelectorAll(".btn")[1]
```

Et hop, tout est beau! Maintenant, si on commence Ã  utiliser CSS-in-JS pour ajouter
du style Ã  notre formulaire, et que nous n'avons plus besoin des class names `username-field` et
`password-field`, est-ce que nous devrions les supprimer? Ou bien on les garde parce que
nos tests les utilisent? Hmmm... ğŸ¤”

## Maintenant, comment est-ce que l'on Ã©crit des sÃ©lecteurs qui sont rÃ©silients?

Sachant que
["le plus que tes tests ressemblent Ã  la faÃ§on dont ton application est utilisÃ©e, le plus de confiance ils peuvent te donner"](https://twitter.com/kentcdodds/status/977018512689455106), ce serait intelligent de notre part de considÃ©rer le fait que nos utilisateurs se fichent de ce que sont nos class names.

Alors, imaginons que l'on a un testeur manuel dans notre Ã©quipe et qu'on lui Ã©crit des instructions pour qu'il puisse tester la page pour nous.
Que diraient ces instructions?

1. va chercher l'Ã©lÃ©ment dont le class name est `username-field`
2. ...

Â« Mais, comment est-ce que je peux trouver l'Ã©lÃ©ment avec le class name `username-field`? Â»

Â« Ah, tu n'as qu'Ã  ouvrir ton devtools et... Â»

Â« Mais nos utilisateurs ne feront pas Ã§a... Pourquoi ne pourrais-je pas trouver le champ abec le libellÃ© "username"? Â»

Â« Ah, oui, bonne idÃ©e! Â»

Voici pourquoi la [react-testing-library](https://testing-library.com) possÃ¨de les requÃªtes qu'elle a. Elles vous aideront Ã  trouver les Ã©lÃ©ments de la mÃªme faÃ§on que les utilisateurs le feraient. Ces requÃªtes vous permettent de trouver des Ã©lÃ©ments selon leur
[rÃ´le](https://testing-library.com/docs/dom-testing-library/api-queries#byrole),
[libellÃ©](https://testing-library.com/docs/dom-testing-library/api-queries#bylabeltext),
[Â« placeholder Â»](https://testing-library.com/docs/dom-testing-library/api-queries#byplaceholdertext),
[contenu textuel](https://testing-library.com/docs/dom-testing-library/api-queries#bytext),
[valeur affichÃ©e](https://testing-library.com/docs/dom-testing-library/api-queries#bydisplayvalue),
[texte alternatif](https://testing-library.com/docs/dom-testing-library/api-queries#byalttext),
[titre](https://testing-library.com/docs/dom-testing-library/api-queries#bytitle) et
[ID de test](https://testing-library.com/docs/dom-testing-library/api-queries#bytestid).

Ils sont d'ailleurs Ã©numÃ©rÃ©s en ordre de [recommendation](https://testing-library.com/docs/guide-which-query). Il y a certainement des compromis avec ces approches, mais si vous deviez
Ã©crire des instructions pour un testeur manuel en utilisant ces requÃªtes-ci, Ã§a ressemblerait Ã  quelque chose du genre :

1. Entre un faux username dans le champ texte libellÃ© `username`
2. Entre un faux password dans le champ libellÃ© `password`
3. Clique sur le bouton avec le texte `sign in`

Et cela aiderait Ã  assurer que vous testz votre application de la maniÃ¨re la plus prÃ¨s possible de la faÃ§on dont elle est utilisÃ©e, vous donnant un test ayant une plus grande valeur.

## Qu'en est-il de la requÃªte des `data-testid`?

Parfois, on ne peut pas sÃ©lectionner un Ã©lÃ©ment par aucune autre requÃªte. Pour ces cas-lÃ , il est recommandÃ© d'utiliser `data-testid` (cependant, il est important de vÃ©rifier que vous n'Ãªtes pas en train d'oublier d'utiliser un rÃ©el attribut de `rÃ´le` en premier lieu).

Plusieurs personnes qui rencontrent cette situation se demandent pourquoi une requÃªte `getByClassName` n'existe pas. Ce wue je n'aime pas en utilisant les **class names** pour mes sÃ©lecteurs c'est qu'en thÃ©orie nous pensons aux noms des **class names** en fonction de leur style. Alors si on se met Ã  ajouter un tas de **class names** qui ne sont pas pour le style, Ã§a rend plis difficile de savoir Ã  quoi servent ces **class names** et si nous pouvons les retirer.

Puis, si nous essayons simplement de reutiliser des **class names** que nous utilisons dÃ©jÃ  pour le style, nous rencontrerons des problÃ¨mes comme celui du bouton ci-haut. _Si tu dois modifier ton test lors d'un refactoring ou d'un nouveau dÃ©veloppement, c'est une indication d'un test faible_. Le rÃ©el problÃ¨me c'est que la relation entre le test et le code source est trop implicite. Nous pourrions solitionner ce problÃ¨me si nous faisions en sorte de **la rendre plus explicite.**

Si nous pouvions ajouter des meta donnÃ©es Ã  l'Ã©lÃ©ment que nous tentons de sÃ©lectionner, Ã§a rÃ©glerait le problÃ¨me. Et bien devinez quoi, il existe un API exprÃ¨s! C'est les attributs `data-`! Par exemple :

```jsx
function UsernameDisplay({ user }) {
  return <strong data-testid="username">{user.username}</strong>
}
```

Et ensuite notre test pourrait faire :

```javascript
const usernameEl = getByTestId("username")
```

C'est Ã©galement intÃ©ressant pour les
[tests end to end](https://github.com/kentcdodds/jest-cypress-react-babel-webpack/blob/1c842dff85cd83953e86a6f1a48653b15fb3a4d5/cypress/e2e/register.js#L20).

Alors je propose que vous l'utilisiez pour ces tests lÃ  aussi! Par contre, certaines personnes m'ont mentionnÃ© qu'ils avaient des doutes quant Ã  mettre ces attributs en production... Si c'est vous, veuillez s'il vous plaÃ®t vous poser la question si cest rÃ©ellement un problÃ¨me pour vous (parce qu'honnÃªtement, ce n'est pas un problÃ¨me aussi gros que vous le pensez). Si vous le dÃ©sirez vraiment, vous pouvez retirer ces atteibuts en compilant avec [`babel-plugin-react-remove-properties`](https://www.npmjs.com/package/babel-plugin-react-remove-properties).

## Conclusion

Vous trouverez que de tester votre application d'une maniere similaire Ã  la faÃ§on dont elle est utilisÃ©e ne rend pas seulement vos tests plus solides aux changements, mais ajoutÃ© Ã©galement de la valeur pour vous. Si vous voulez en apprendre davantage Ã  propos de Ã§a, he vous propose de lire l'article suivant (sur le site de Kent C. Dodds) [Testing Implementation Details](/blog/testing-implementation-details).

J'espÃ¨re que cet article vous aura Ã©tÃ© utile!
