---
slug: making-your-ui-tests-resilient-to-change
title: Rendre vos tests UI rÃ©silients aux changements
date: "2019-10-07"
author: Kent C. Dodds
traductor: Louis-Bernard Poulin Martel
description: >-
  _Les tests d'interface utilisateur sont reconnus pour briser facilement. Voyons
  comment nous pourrions amÃ©liorer ceci._
keywords:
  - javascript
  - testing
  - Ui Testing
  - Unit Testing
  - Integration Testing
banner: ./images/banner.jpg
bannerCredit: "Photo by [Warren Wong](https://unsplash.com/photos/tHiGKAJxaA8)"
---

Version originale :

- [Article Â«Making your UI tests resilient to changeÂ» de Kent C. Dodds](https://kentcdodds.com/blog/making-your-ui-tests-resilient-to-change)

Traductions libres prÃ©sentement disponibles :

- [Chinois traditionel](https://medium.com/enjoy-life-enjoy-coding/react-unit-test-%E8%AE%93%E4%BD%A0%E7%9A%84-ui-%E6%B8%AC%E8%A9%A6%E9%81%A9%E6%87%89%E8%AE%8A%E5%8C%96-%E7%BF%BB%E8%AD%AF-b9b2c1c4110f)

Vous Ãªtes un dÃ©veloppeur et vous voulez Ã©viter de livrer un service de connexion qui ne
fonctionne pas. Vous Ã©crivez donc des tests pour vous assurer que Ã§a n'arrive pas.
Regardons ici un exemple d'un [formulaire de ce genre](https://github.com/kentcdodds/testing-workshop/blob/1938d6fc2048e55362679905f700f938a3b497c4/client/src/screens/login.js#L50-L82) :

![Login form from the Bookshelf App](./images/login.png)

```jsx
const form = (
  <form onSubmit={handleSubmit}>
    <div>
      <label htmlFor="username">Username</label>
      <input id="username" className="username-field" />
    </div>
    <div>
      <label htmlFor="password">Password</label>
      <input id="password" type="password" className="password-field" />
    </div>
    <div>
      <button type="submit" className="btn">
        Login
      </button>
    </div>
  </form>
);
```

Si nous avions Ã  tester ce formulaire, nous voudrions remplir le champ Â« username Â»,
le champ Â« password Â» et ensuite soumettre le formulaire. Pour faire cela correctement,
nous aurions Ã  rendre le formulaire et trouver les noeuds dans le document pour pouvoir
les utiliser. Voici ce que vous pourriez vouloir faire pour que cela se produise :

```js
const usernameField = rootNode.querySelector(".username-field");
const passwordField = rootNode.querySelector(".password-field");
const submitButton = rootNode.querySelector(".btn");
```

C'est ici que le problÃ¨me entre en jeu. Qu'arrive-t-il lorsque l'on ajoute un autre
bouton? Que se passerait-il si l'on ajoutait un bouton Â« Sign up Â» avant le bouton
Â« Login Â»?

```jsx {12-14}
const form = (
  <form onSubmit={handleSubmit}>
    <div>
      <label htmlFor="username">Username</label>
      <input id="username" className="username-field" />
    </div>
    <div>
      <label htmlFor="password">Password</label>
      <input id="password" type="password" className="password-field" />
    </div>
    <div>
      <button type="submit" className="btn">
        Sign up
      </button>
      <button type="submit" className="btn">
        Login
      </button>
    </div>
  </form>
);
```

Et bien, Ã§a va briser nos tests. Mais ce serait assez simple Ã  rÃ©parer, n'est-ce pas?

```js
// changer ceci :
const submitButton = rootNode.querySelector(".btn");
// pour ceci :
const submitButton = rootNode.querySelectorAll(".btn")[1];
```

Et hop, tout est beau! Maintenant, si on commence Ã  utiliser CSS-in-JS pour ajouter
du style Ã  notre formulaire, et que nous n'avons plus besoin des class names `username-field` et
`password-field`, est-ce que nous devrions les supprimer? Ou bien on les garde parce que
nos tests les utilisent? Hmmm... ðŸ¤”

## Maintenant, comment est-ce que l'on Ã©crit des sÃ©lecteurs qui sont rÃ©silients?

Sachant que
["le plus que tes tests ressemblent Ã  la faÃ§on dont ton application est utilisÃ©e, le plus de confiance ils peuvent te donner"](https://twitter.com/kentcdodds/status/977018512689455106), ce serait intelligent de notre part de considÃ©rer le fait que nos utilisateurs se fichent de ce que sont nos class names.

Alors, imaginons que l'on a un testeur manuel dans notre Ã©quipe et qu'on lui Ã©crit des instructions pour qu'il puisse tester la page pour nous. 
Que diraient ces instructions?

1. va chercher l'Ã©lÃ©ment dont le class name est `username-field`
2. ...

Â« Mais, comment est-ce que je peux trouver l'Ã©lÃ©ment avec le class name `username-field`? Â»

Â« Ah, tu n'as qu'Ã  ouvrir ton devtools et... Â»

Â« Mais nos utilisateurs ne feront pas Ã§a... Pourquoi ne pourrais-je pas trouver le champ abec le libellÃ© "username"? Â»

Â« Ah, oui, bonne idÃ©e! Â»

Voici pourquoi la [react-testing-library](https://testing-library.com) possÃ¨de les requÃªtes qu'elle a. Elles vous aideront Ã  trouver les Ã©lÃ©ments de la mÃªme faÃ§on que les utilisateurs le feraient. Ces requÃªtes vous permettent de trouver des Ã©lÃ©ments selon leur 
[rÃ´le](https://testing-library.com/docs/dom-testing-library/api-queries#byrole),
[libellÃ©](https://testing-library.com/docs/dom-testing-library/api-queries#bylabeltext),
[Â« placeholder Â»](https://testing-library.com/docs/dom-testing-library/api-queries#byplaceholdertext),
[contenu textuel](https://testing-library.com/docs/dom-testing-library/api-queries#bytext),
[valeur affichÃ©e](https://testing-library.com/docs/dom-testing-library/api-queries#bydisplayvalue),
[texte alternatif](https://testing-library.com/docs/dom-testing-library/api-queries#byalttext),
[titre](https://testing-library.com/docs/dom-testing-library/api-queries#bytitle) et
[ID de test](https://testing-library.com/docs/dom-testing-library/api-queries#bytestid).

Ils sont d'ailleurs Ã©numÃ©rÃ©s en ordre de [recommendation](https://testing-library.com/docs/guide-which-query). Il y a certainement des compromis avec ces approches, mais si vous deviez
Ã©crire des instructions pour un testeur manuel en utilisant ces requÃªtes-ci, Ã§a ressemblerait Ã  quelque chose du genre :
1. Entre un faux username dans le champ texte libellÃ© `username`
2. Entre un faux password dans le champ libellÃ© `password`
3. Clique sur le bouton avec le texte `sign in`

Et cela aiderait Ã  assurer que vous testz votre application de la maniÃ¨re la plus prÃ¨s possible de la faÃ§on dont elle est utilisÃ©e, vous donnant un test ayant une plus grande valeur.

## Qu'en est-il de la requÃªte des `data-testid`?

Parfois, on ne peut pas sÃ©lectionner un Ã©lÃ©ment par aucune autre requÃªte. Pour ces cas-lÃ , il est recommandÃ© d'utiliser `data-testid` (cependant, il est important de vÃ©rifier que vous n'Ãªtes pas en train d'oublier d'utiliser un rÃ©el attribut de `rÃ´le` en premier lieu).

Many people who hit this situation, wonder why we don't include a
`getByClassName` query. What I don't like about using class names for my
selectors is that normally we think of class names as a way to style things. So
when we start adding a bunch of class names that are not for that purpose it
makes it even **_harder_** to know what those class names are for and when we
can remove class names.

And if we simply try to reuse class names that we're already just using for
styling then we run into issues like the button up above. And _any time you have
to change your tests when you refactor or add a feature, that's an indication of
a brittle test_. The core issue is that the relationship between the test and
the source code is too implicit. We can overcome this issue if we **make that
relationship more explicit.**

If we could add some metadata to the element we're trying to select that would
solve the problem. Well guess what! There's actually an existing API for this!
It's `data-` attributes! For example:

```jsx
function UsernameDisplay({ user }) {
  return <strong data-testid="username">{user.username}</strong>;
}
```


And then our test can say:

```javascript
const usernameEl = getByTestId("username");
```

This is great for
[end to end tests](https://github.com/kentcdodds/jest-cypress-react-babel-webpack/blob/1c842dff85cd83953e86a6f1a48653b15fb3a4d5/cypress/e2e/register.js#L20)
as well. So I suggest that you use it for that too! However, some folks have
expressed to me concern about shipping these attributes to production. If that's
you, please really consider whether it's actually a problem for you (because
honestly it's probably not as big a deal as you think it is). If you really want
to, you can compile those attributes away with
[`babel-plugin-react-remove-properties`](https://www.npmjs.com/package/babel-plugin-react-remove-properties).

## Conclusion

You'll find that testing your applications in a way that's similar to how your
software is used makes your tests not only more resilient to changes, but also
provide more value to you. If you want to learn more about this, then I suggest
you read more in my blog post
[Testing Implementation Details](/blog/testing-implementation-details).

I hope this is helpful to you. Good luck!
